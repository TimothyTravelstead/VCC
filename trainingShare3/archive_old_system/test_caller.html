<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Caller Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #e3f2fd; }
        button { padding: 10px 20px; margin: 5px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #log { background: #f5f5f5; padding: 10px; height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        video { width: 300px; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <h1>WebRTC Screen Share Caller</h1>
    <button onclick="startCall()">Start Screen Share</button>
    <button onclick="clearLog()">Clear Log</button>
    
    <div>
        <h3>Screen Preview:</h3>
        <video id="localVideo" autoplay muted></video>
    </div>
    
    <div>
        <h3>Log:</h3>
        <div id="log"></div>
    </div>

    <script>
        const myId = 'caller';
        let peerConnections = new Map(); // receiverId -> peerConnection
        let localStream = null;
        let lastMessageTime = 0;
        let isSharing = false;
        
        function log(msg) {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${time}] ${msg}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        async function sendMessage(message, targetId = 'receiver') {
            message.from = myId;
            message.to = targetId;
            
            try {
                const response = await fetch('minimal_signaling_test.php', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(message)
                });
                const result = await response.json();
                log(`SENT: ${message.type} to ${targetId} - ${result.status}`);
            } catch (error) {
                log(`ERROR sending: ${error.message}`);
            }
        }
        
        async function pollMessages() {
            try {
                const response = await fetch(`minimal_signaling_test.php?to=${myId}&since=${lastMessageTime}`);
                const result = await response.json();
                
                if (result.messages) {
                    for (const msg of result.messages) {
                        log(`RECEIVED: ${msg.type} from ${msg.from}`);
                        handleMessage(msg);
                        lastMessageTime = Math.max(lastMessageTime, msg.timestamp);
                    }
                }
            } catch (error) {
                log(`ERROR polling: ${error.message}`);
            }
        }
        
        function handleMessage(msg) {
            const receiverId = msg.from;
            
            switch (msg.type) {
                case 'join-request':
                    log(`Receiver ${receiverId} wants to join`);
                    if (isSharing && localStream) {
                        createPeerConnectionForReceiver(receiverId);
                    }
                    break;
                case 'answer':
                    const pc = peerConnections.get(receiverId);
                    if (pc) {
                        pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
                        log(`Remote description set for ${receiverId}`);
                    }
                    break;
                case 'ice-candidate':
                    const pcForIce = peerConnections.get(receiverId);
                    if (pcForIce) {
                        pcForIce.addIceCandidate(new RTCIceCandidate(msg.candidate));
                        log(`ICE candidate added for ${receiverId}`);
                    }
                    break;
            }
        }
        
        async function createPeerConnectionForReceiver(receiverId) {
            // Check if we already have a connection for this receiver
            if (peerConnections.has(receiverId)) {
                log(`Peer connection already exists for ${receiverId} - skipping`);
                return;
            }
            
            log(`Creating NEW peer connection for ${receiverId} (total: ${peerConnections.size + 1})`);
            
            const pc = new RTCPeerConnection({
                iceServers: [{'urls': 'stun:stun.l.google.com:19302'}]
            });
            
            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendMessage({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }, receiverId);
                }
            };
            
            // Add local stream tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
                log(`Added stream tracks for ${receiverId}`);
            }
            
            // Store peer connection
            peerConnections.set(receiverId, pc);
            
            // Create and send offer
            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                sendMessage({
                    type: 'offer',
                    offer: offer
                }, receiverId);
                
                log(`Offer sent to ${receiverId}`);
            } catch (error) {
                log(`Error creating offer for ${receiverId}: ${error.message}`);
            }
        }
        
        async function startCall() {
            log('Starting screen share...');
            
            // Get screen share
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({video: true, audio: false});
                document.getElementById('localVideo').srcObject = localStream;
                isSharing = true;
                
                log('Screen share stream added - ready for receivers');
                
                // Send a heartbeat message to indicate we're active
                sendMessage({
                    type: 'caller-active'
                }, 'broadcast');
                
            } catch (error) {
                log(`ERROR: ${error.message}`);
            }
        }
        
        // Send heartbeat every 30 seconds to keep caller active
        setInterval(() => {
            if (isSharing) {
                sendMessage({
                    type: 'caller-active'
                }, 'broadcast');
                log('Heartbeat sent');
            }
        }, 30000);
        
        // Poll for messages every 1 second
        setInterval(pollMessages, 1000);
        
        log('Caller page loaded');
    </script>
</body>
</html>