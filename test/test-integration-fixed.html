<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenSharingControl - Fixed Integration Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #fafafa; }
        .session-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .session-box { border: 2px solid #007bff; border-radius: 8px; padding: 15px; background: #f8f9ff; }
        .trainer-box { border-color: #28a745; background: #f8fff8; }
        .trainee-box { border-color: #17a2b8; background: #f8ffff; }
        video { width: 100%; height: 200px; background: #000; border-radius: 4px; margin: 10px 0; }
        button { padding: 8px 16px; margin: 4px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        button:hover { opacity: 0.8; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { padding: 5px 10px; border-radius: 3px; font-size: 12px; font-weight: bold; margin: 5px 0; }
        .status-connected { background: #d4edda; color: #155724; }
        .status-disconnected { background: #f8d7da; color: #721c24; }
        .status-pending { background: #fff3cd; color: #856404; }
        .log-box { height: 300px; overflow-y: scroll; background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; font-family: monospace; font-size: 11px; white-space: pre-wrap; }
        .connection-info { font-size: 10px; color: #666; margin: 5px 0; }
        .sequence-box { background: #e7f3ff; border: 1px solid #b3d9ff; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .step { margin: 5px 0; }
        .step.completed { color: #28a745; font-weight: bold; }
        .step.active { color: #007bff; font-weight: bold; }
        .step.pending { color: #6c757d; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ ScreenSharingControl - Fixed Integration Test</h1>
        <p><strong>Proper sequence testing with live servers</strong></p>
        
        <div class="test-section">
            <h3>üìã Correct Sequence</h3>
            <div class="sequence-box">
                <div id="step1" class="step pending">1. Initialize both sessions</div>
                <div id="step2" class="step pending">2. Get trainer screen capture</div>
                <div id="step3" class="step pending">3. Start trainer screen sharing</div>
                <div id="step4" class="step pending">4. Trainee connects automatically</div>
                <div id="step5" class="step pending">5. WebRTC peer connection established</div>
                <div id="step6" class="step pending">6. Video stream appears on trainee</div>
            </div>
        </div>
        
        <div class="test-section">
            <h3>üéÆ Test Controls</h3>
            <button onclick="runCorrectSequence()" class="btn-primary">Run Correct Sequence</button>
            <button onclick="initializeSessions()" class="btn-success">1. Initialize Sessions</button>
            <button onclick="getScreenAndStart()" class="btn-success">2. Get Screen & Start Sharing</button>
            <button onclick="connectTrainee()" class="btn-success">3. Connect Trainee</button>
            <button onclick="cleanupSessions()" class="btn-danger">Cleanup Sessions</button>
            <button onclick="clearLog()" class="btn-primary">Clear Log</button>
        </div>

        <div class="session-container">
            <div class="session-box trainer-box">
                <h3>üë®‚Äçüè´ Trainer Session</h3>
                <div id="trainerStatus" class="status status-disconnected">Disconnected</div>
                <video id="trainerVideo" muted></video>
                <div class="connection-info">
                    <div>API: <span id="trainerAPI">‚ùå</span></div>
                    <div>SSE: <span id="trainerSSE">‚ùå</span></div>
                    <div>WebRTC: <span id="trainerWebRTC">‚ùå</span></div>
                    <div>Sharing: <span id="trainerSharing">‚ùå</span></div>
                    <div>Peers: <span id="trainerPeers">0</span></div>
                </div>
            </div>

            <div class="session-box trainee-box">
                <h3>üë®‚Äçüéì Trainee Session</h3>
                <div id="traineeStatus" class="status status-disconnected">Disconnected</div>
                <video id="traineeVideo" muted autoplay></video>
                <div class="connection-info">
                    <div>API: <span id="traineeAPI">‚ùå</span></div>
                    <div>SSE: <span id="traineeSSE">‚ùå</span></div>
                    <div>WebRTC: <span id="traineeWebRTC">‚ùå</span></div>
                    <div>Receiving: <span id="traineeReceiving">‚ùå</span></div>
                    <div>Peers: <span id="traineePeers">0</span></div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>üìù Test Log</h3>
            <div id="testLog" class="log-box"></div>
        </div>
    </div>

    <!-- Load Socket.IO for WebRTC signaling -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <!-- Load the ScreenSharingControl class -->
    <script src="trainingShare/screenSharingControl.js"></script>

    <script>
        // Global session variables
        let trainerSession = null;
        let traineeSession = null;
        let currentStep = 0;

        // Logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('testLog');
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logDiv.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            document.getElementById('testLog').textContent = '';
        }

        function updateStep(stepNumber, status = 'active') {
            // Update previous steps to completed
            for (let i = 1; i < stepNumber; i++) {
                const stepElement = document.getElementById(`step${i}`);
                if (stepElement) {
                    stepElement.className = 'step completed';
                }
            }
            
            // Update current step
            const currentStepElement = document.getElementById(`step${stepNumber}`);
            if (currentStepElement) {
                currentStepElement.className = `step ${status}`;
            }
            
            currentStep = stepNumber;
        }

        function updateStatus(role, status) {
            const statusElement = document.getElementById(`${role}Status`);
            statusElement.textContent = status;
            statusElement.className = `status ${status.toLowerCase().includes('connected') || status.toLowerCase().includes('sharing') ? 'status-connected' : 
                                              status.toLowerCase().includes('error') || status.toLowerCase().includes('failed') ? 'status-disconnected' : 'status-pending'}`;
        }

        function updateConnectionIndicator(role, type, value) {
            const element = document.getElementById(`${role}${type}`);
            if (element) {
                element.textContent = typeof value === 'boolean' ? (value ? '‚úÖ' : '‚ùå') : value;
            }
        }

        function monitorSession(session, role) {
            // Monitor connection states with detailed logging
            const checkConnections = () => {
                updateConnectionIndicator(role, 'API', session.apiReady);
                updateConnectionIndicator(role, 'SSE', session.sseReady);
                updateConnectionIndicator(role, 'WebRTC', session.socketReady);
                updateConnectionIndicator(role, 'Sharing', session.isSharing);
                updateConnectionIndicator(role, 'Peers', session.peers.size);
                
                // Log connection state changes
                if (session.apiReady && session.sseReady && session.socketReady) {
                    updateStatus(role, 'All Systems Connected');
                } else if (session.apiReady && session.sseReady) {
                    updateStatus(role, 'API + SSE Connected');
                } else if (session.apiReady) {
                    updateStatus(role, 'API Connected');
                } else {
                    updateStatus(role, 'Connecting...');
                }
                
                if (role === 'trainee') {
                    const hasVideo = session.remoteVideo && session.remoteVideo.srcObject;
                    updateConnectionIndicator(role, 'Receiving', hasVideo);
                    if (hasVideo) {
                        updateStatus(role, 'üéâ Receiving Video');
                    }
                }
            };
            
            // Check every 1 second for faster feedback
            setInterval(checkConnections, 1000);
            
            // Monitor peer events
            const originalGetOrCreatePeer = session.getOrCreatePeer.bind(session);
            session.getOrCreatePeer = function(peerId) {
                log(`${role}: Creating peer connection to ${peerId}`);
                const result = originalGetOrCreatePeer(peerId);
                
                // Add detailed peer monitoring
                result.ontrack = (event) => {
                    log(`${role}: Received remote stream from ${peerId}`, 'success');
                    if (session.remoteVideo && event.streams && event.streams[0]) {
                        session.remoteVideo.srcObject = event.streams[0];
                        session.remoteVideo.style.display = 'block';
                        if (role === 'trainee') {
                            updateStep(6, 'completed');
                            log('üéâ Screen sharing working! Video stream displayed.', 'success');
                        }
                    }
                };
                
                result.oniceconnectionstatechange = () => {
                    log(`${role}: ICE connection state with ${peerId}: ${result.iceConnectionState}`);
                    if (result.iceConnectionState === 'connected' || result.iceConnectionState === 'completed') {
                        updateStep(5, 'completed');
                    }
                };
                
                return result;
            };
            
            // Monitor signaling
            const originalHandleWebRTCSignal = session.handleWebRTCSignal.bind(session);
            session.handleWebRTCSignal = function(data) {
                log(`${role}: WebRTC signal: ${data.type} from ${data.fromUserId || data.from}`);
                return originalHandleWebRTCSignal(data);
            };
        }

        async function initializeSessions() {
            updateStep(1, 'active');
            log('Step 1: Initializing trainer and trainee sessions...');
            log('üîß Testing PRODUCTION SSE endpoint and Socket.IO polling...');

            try {
                // Create trainer session
                log('Creating trainer session...');
                updateStatus('trainer', 'Creating...');
                
                trainerSession = new ScreenSharingControl({
                    volunteerID: 'fixed-trainer-test',
                    role: 'trainer',
                    roomName: 'fixed-test-room',
                    trainerID: 'fixed-trainer-test',
                    trainees: [{ id: 'fixed-trainee-test', isSignedOn: true }],
                    sessionToken: getTestSessionToken()
                });
                
                // Disable auto-start for controlled testing
                trainerSession.autoStarted = true;

                trainerSession.remoteVideo = document.getElementById('trainerVideo');
                monitorSession(trainerSession, 'trainer');

                log('Initializing trainer session (API ‚Üí Room Join ‚Üí SSE ‚Üí WebRTC)...');
                const startTime = performance.now();
                await trainerSession.init();
                const endTime = performance.now();
                updateStatus('trainer', 'Initialized');
                log(`‚úÖ Trainer session initialized in ${Math.round(endTime - startTime)}ms`, 'success');
                
                // Validate all connections
                log(`Trainer - API: ${trainerSession.apiReady}, SSE: ${trainerSession.sseReady}, WebRTC: ${trainerSession.socketReady}`);
                if (!trainerSession.apiReady) log('‚ùå Trainer API connection failed', 'error');
                if (!trainerSession.sseReady) log('‚ùå Trainer SSE connection failed', 'error');
                if (!trainerSession.socketReady) log('‚ö†Ô∏è Trainer WebRTC signalling failed (may be expected)', 'warning');

                // Create trainee session
                log('Creating trainee session...');
                updateStatus('trainee', 'Creating...');
                
                traineeSession = new ScreenSharingControl({
                    volunteerID: 'fixed-trainee-test',
                    role: 'trainee',
                    roomName: 'fixed-test-room',
                    trainerID: 'fixed-trainer-test',
                    trainees: [],
                    sessionToken: getTestSessionToken()
                });

                traineeSession.remoteVideo = document.getElementById('traineeVideo');
                monitorSession(traineeSession, 'trainee');

                log('Initializing trainee session (API ‚Üí Room Join ‚Üí SSE ‚Üí WebRTC)...');
                const traineeStartTime = performance.now();
                await traineeSession.init();
                const traineeEndTime = performance.now();
                updateStatus('trainee', 'Initialized');
                log(`‚úÖ Trainee session initialized in ${Math.round(traineeEndTime - traineeStartTime)}ms`, 'success');
                
                // Validate all connections
                log(`Trainee - API: ${traineeSession.apiReady}, SSE: ${traineeSession.sseReady}, WebRTC: ${traineeSession.socketReady}`);
                if (!traineeSession.apiReady) log('‚ùå Trainee API connection failed', 'error');
                if (!traineeSession.sseReady) log('‚ùå Trainee SSE connection failed', 'error');
                if (!traineeSession.socketReady) log('‚ö†Ô∏è Trainee WebRTC signalling failed (may be expected)', 'warning');

                updateStep(1, 'completed');
                log('‚úÖ Step 1 completed: Both sessions initialized!', 'success');
                log(`üöÄ Total initialization time: ${Math.round(endTime - startTime + traineeEndTime - traineeStartTime)}ms`);

            } catch (error) {
                log(`‚ùå Step 1 failed: ${error.message}`, 'error');
                updateStatus('trainer', 'Init Failed');
                updateStatus('trainee', 'Init Failed');
            }
        }

        async function getScreenAndStart() {
            if (!trainerSession) {
                log('‚ùå Initialize sessions first', 'error');
                return;
            }

            updateStep(2, 'active');
            log('Step 2: Getting trainer screen capture...');

            try {
                updateStatus('trainer', 'Requesting Screen...');

                // Get screen capture
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { width: 1920, height: 1080 },
                    audio: false
                });

                // Set the stream on trainer video for preview
                document.getElementById('trainerVideo').srcObject = stream;
                
                updateStep(2, 'completed');
                log('‚úÖ Step 2 completed: Screen captured!', 'success');

                // Immediately move to step 3
                updateStep(3, 'active');
                log('Step 3: Starting trainer screen sharing...');
                updateStatus('trainer', 'Starting Share...');

                // Store stream and start sharing
                trainerSession.localStream = stream;
                await trainerSession.startScreenShare();
                
                updateStatus('trainer', 'Sharing Active');
                updateStep(3, 'completed');
                log('‚úÖ Step 3 completed: Trainer is now sharing!', 'success');

                // Auto-trigger trainee connection
                setTimeout(() => {
                    connectTrainee();
                }, 2000);

            } catch (error) {
                if (error.name === 'NotAllowedError') {
                    log('‚ùå Screen sharing permission denied', 'error');
                } else {
                    log(`‚ùå Screen sharing failed: ${error.message}`, 'error');
                }
                updateStatus('trainer', 'Share Failed');
            }
        }

        function connectTrainee() {
            if (!traineeSession) {
                log('‚ùå Initialize sessions first', 'error');
                return;
            }

            updateStep(4, 'active');
            log('Step 4: Connecting trainee to trainer...');
            updateStatus('trainee', 'Connecting...');

            traineeSession.connectToSharer('fixed-trainer-test');
            
            updateStep(4, 'completed');
            updateStatus('trainee', 'Connected');
            log('‚úÖ Step 4 completed: Trainee connected!', 'success');

            // Monitor for peer connection establishment
            setTimeout(() => {
                if (trainerSession.peers.size > 0 || traineeSession.peers.size > 0) {
                    updateStep(5, 'active');
                    log('Step 5: WebRTC peer connections establishing...', 'warning');
                } else {
                    log('‚ö†Ô∏è No peer connections detected yet. This may take a moment.', 'warning');
                }
            }, 3000);
        }

        async function runCorrectSequence() {
            log('üöÄ Running the correct screen sharing sequence...');
            clearLog();

            updateStep(1, 'active');
            
            // Step 1: Initialize
            await initializeSessions();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Step 2 & 3: Get screen and start sharing
            await getScreenAndStart();
            
            // Steps 4-6 happen automatically in getScreenAndStart
        }

        async function cleanupSessions() {
            log('Cleaning up sessions...');

            if (trainerSession) {
                try {
                    await trainerSession.destroy();
                    log('Trainer session destroyed', 'success');
                } catch (error) {
                    log(`Trainer cleanup error: ${error.message}`, 'error');
                }
                trainerSession = null;
            }

            if (traineeSession) {
                try {
                    await traineeSession.destroy();
                    log('Trainee session destroyed', 'success');
                } catch (error) {
                    log(`Trainee cleanup error: ${error.message}`, 'error');
                }
                traineeSession = null;
            }

            // Reset UI
            updateStatus('trainer', 'Disconnected');
            updateStatus('trainee', 'Disconnected');
            
            ['trainer', 'trainee'].forEach(role => {
                ['API', 'SSE', 'WebRTC', 'Sharing', 'Receiving', 'Peers'].forEach(type => {
                    updateConnectionIndicator(role, type, type === 'Peers' ? '0' : false);
                });
            });

            // Reset steps
            for (let i = 1; i <= 6; i++) {
                const stepElement = document.getElementById(`step${i}`);
                if (stepElement) {
                    stepElement.className = 'step pending';
                }
            }
            currentStep = 0;

            // Clear videos
            document.getElementById('trainerVideo').srcObject = null;
            document.getElementById('traineeVideo').srcObject = null;

            log('Cleanup completed', 'success');
        }

        function getTestSessionToken() {
            // Try to get a real session token from the page
            const sources = [
                () => document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
                () => document.getElementById('sessionToken')?.value,
                () => localStorage.getItem('volunteerSessionToken'),
                () => 'fixed-integration-test-token-1234567890' // Fallback for testing
            ];
            
            for (const source of sources) {
                const token = source();
                if (token && token.length > 10) {
                    return token;
                }
            }
            
            return 'fixed-integration-test-token-1234567890';
        }

        // Add comprehensive testing functions
        function testSSEEndpoint() {
            log('üîç Testing PRODUCTION SSE endpoint directly...');
            const testUrl = 'https://share.volunteerlogin.org/sse-production.php?room_id=test&user_id=test-user&connection_id=1';
            
            const eventSource = new EventSource(testUrl);
            let messageCount = 0;
            const startTime = performance.now();
            
            eventSource.onopen = () => {
                const connectTime = performance.now() - startTime;
                log(`‚úÖ SSE connected in ${Math.round(connectTime)}ms`, 'success');
            };
            
            eventSource.onmessage = (event) => {
                messageCount++;
                const data = JSON.parse(event.data);
                log(`üì® SSE message ${messageCount}: ${data.type}`);
            };
            
            // Complete test after 30 seconds to see production heartbeats
            setTimeout(() => {
                const totalTime = performance.now() - startTime;
                eventSource.close();
                log(`‚úÖ SSE test complete: ${messageCount} messages in ${Math.round(totalTime)}ms`, 'success');
            }, 30000);
            
            eventSource.onerror = (event) => {
                // Don't log error if we've already received messages - this is normal when endpoint exits
                if (messageCount === 0) {
                    log('‚ùå SSE connection failed', 'error');
                } else {
                    log(`‚ÑπÔ∏è SSE endpoint closed (normal - received ${messageCount} messages)`);
                }
                eventSource.close();
            };
        }
        
        function testSocketIO() {
            log('üîç Testing Socket.IO connection...');
            const startTime = performance.now();
            
            const socket = io('https://share.volunteerlogin.org', {
                transports: ['polling'],
                forceNew: true,
                upgrade: false
            });
            
            socket.on('connect', () => {
                const connectTime = performance.now() - startTime;
                log(`‚úÖ Socket.IO connected via ${socket.io.engine.transport.name} in ${Math.round(connectTime)}ms`, 'success');
                socket.disconnect();
            });
            
            socket.on('connect_error', (error) => {
                log(`‚ùå Socket.IO failed: ${error.message}`, 'error');
            });
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('üéØ ScreenSharingControl Fixed Integration Test loaded');
            log('üì° This test validates the complete screen sharing workflow');
            log('üîß Testing PRODUCTION SSE endpoint and Socket.IO polling configuration');
            log('‚ÑπÔ∏è Click "Run Correct Sequence" to test the full workflow');
            
            // Add test buttons to the controls
            const controlsSection = document.querySelector('.test-section');
            const testButtons = document.createElement('div');
            testButtons.innerHTML = `
                <button onclick="testSSEEndpoint()" class="btn-warning">Test SSE Endpoint</button>
                <button onclick="testSocketIO()" class="btn-warning">Test Socket.IO</button>
            `;
            controlsSection.appendChild(testButtons);
        });
    </script>
</body>
</html>