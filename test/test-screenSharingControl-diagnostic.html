<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenSharingControl Diagnostic Test</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
        }
        .test-section { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 5px; 
            background: #fafafa;
        }
        .diagnostic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .diagnostic-box {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            background: white;
        }
        .status-indicator {
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            margin: 5px 0;
        }
        .status-ok { background: #d4edda; color: #155724; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-pending { background: #fff3cd; color: #856404; }
        button {
            padding: 8px 16px;
            margin: 4px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        button:hover { opacity: 0.8; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .log-box {
            height: 400px;
            overflow-y: scroll;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            white-space: pre-wrap;
        }
        .response-details {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç ScreenSharingControl Diagnostic Test</h1>
        <p><strong>Diagnosing connection issues with live servers</strong></p>
        
        <div class="test-section">
            <h3>üîß Diagnostic Controls</h3>
            <button onclick="testAllEndpoints()" class="btn-primary">Test All Endpoints</button>
            <button onclick="testAPIConnectivity()" class="btn-success">Test API</button>
            <button onclick="testSSEConnectivity()" class="btn-success">Test SSE</button>
            <button onclick="testWebRTCSignaler()" class="btn-success">Test WebRTC Signaler</button>
            <button onclick="testWithDifferentAuth()" class="btn-warning">Test Different Auth</button>
            <button onclick="clearLog()" class="btn-danger">Clear Log</button>
        </div>

        <div class="diagnostic-grid">
            <div class="diagnostic-box">
                <h4>üåê API Connectivity</h4>
                <div id="apiStatus" class="status-indicator status-pending">Not Tested</div>
                <div id="apiDetails" class="response-details">Click "Test API" to check connectivity</div>
                <button onclick="testAPIConnectivity()" class="btn-primary">Test API</button>
            </div>

            <div class="diagnostic-box">
                <h4>üì° SSE Connectivity</h4>
                <div id="sseStatus" class="status-indicator status-pending">Not Tested</div>
                <div id="sseDetails" class="response-details">Click "Test SSE" to check connectivity</div>
                <button onclick="testSSEConnectivity()" class="btn-primary">Test SSE</button>
            </div>

            <div class="diagnostic-box">
                <h4>üîó WebRTC Signaler</h4>
                <div id="webrtcStatus" class="status-indicator status-pending">Not Tested</div>
                <div id="webrtcDetails" class="response-details">Click "Test WebRTC Signaler" to check</div>
                <button onclick="testWebRTCSignaler()" class="btn-primary">Test WebRTC</button>
            </div>

            <div class="diagnostic-box">
                <h4>üîê Authentication</h4>
                <div id="authStatus" class="status-indicator status-pending">Not Tested</div>
                <div id="authDetails" class="response-details">Click "Test Different Auth" to check auth methods</div>
                <button onclick="testWithDifferentAuth()" class="btn-primary">Test Auth</button>
            </div>
        </div>

        <div class="test-section">
            <h3>üìù Diagnostic Log</h3>
            <div id="diagnosticLog" class="log-box"></div>
        </div>
    </div>

    <!-- Load Socket.IO for WebRTC signaling tests -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <!-- Load the ScreenSharingControl class -->
    <script src="trainingShare/screenSharingControl.js"></script>

    <script>
        // Diagnostic functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('diagnosticLog');
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logDiv.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            document.getElementById('diagnosticLog').textContent = '';
        }

        function updateStatus(component, status, details = '') {
            const statusElement = document.getElementById(`${component}Status`);
            const detailsElement = document.getElementById(`${component}Details`);
            
            if (statusElement) {
                statusElement.textContent = status;
                statusElement.className = `status-indicator ${status.toLowerCase().includes('success') || status.toLowerCase().includes('connected') ? 'status-ok' : 
                                                              status.toLowerCase().includes('fail') || status.toLowerCase().includes('error') ? 'status-error' : 'status-pending'}`;
            }
            
            if (detailsElement && details) {
                detailsElement.textContent = details;
            }
        }

        async function testAPIConnectivity() {
            log('üåê Testing API connectivity...');
            updateStatus('api', 'Testing...', 'Checking API endpoints...');

            const endpoints = [
                { url: 'https://share.volunteerlogin.org/api.php/health', name: 'Health Check' },
                { url: 'https://share.volunteerlogin.org/api.php', name: 'Base API' },
                { url: 'https://share.volunteerlogin.org/', name: 'Root Domain' }
            ];

            let results = [];
            
            for (const endpoint of endpoints) {
                try {
                    log(`Testing ${endpoint.name}: ${endpoint.url}`);
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch(endpoint.url, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    const responseText = await response.text();
                    const result = {
                        name: endpoint.name,
                        status: response.status,
                        statusText: response.statusText,
                        ok: response.ok,
                        headers: Object.fromEntries(response.headers.entries()),
                        body: responseText.substring(0, 500) // First 500 chars
                    };
                    
                    results.push(result);
                    log(`${endpoint.name}: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                    
                } catch (error) {
                    const result = {
                        name: endpoint.name,
                        error: error.message,
                        type: error.name
                    };
                    
                    results.push(result);
                    log(`${endpoint.name}: ${error.message}`, 'error');
                }
            }
            
            const successCount = results.filter(r => r.ok).length;
            const status = successCount > 0 ? `${successCount}/${endpoints.length} Success` : 'All Failed';
            const details = JSON.stringify(results, null, 2);
            
            updateStatus('api', status, details);
            log(`API Test Complete: ${status}`, successCount > 0 ? 'success' : 'error');
        }

        async function testSSEConnectivity() {
            log('üì° Testing SSE connectivity...');
            updateStatus('sse', 'Testing...', 'Connecting to SSE endpoint...');

            try {
                const sseUrl = 'https://share.volunteerlogin.org/SSE.php?room_id=diagnostic-test&user_id=diagnostic-user&connection_id=1';
                log(`SSE URL: ${sseUrl}`);
                
                const eventSource = new EventSource(sseUrl);
                
                let connected = false;
                let messages = [];
                
                const timeout = setTimeout(() => {
                    if (!connected) {
                        eventSource.close();
                        updateStatus('sse', 'Timeout', 'SSE connection timed out after 15 seconds');
                        log('SSE connection timed out', 'error');
                    }
                }, 15000);
                
                eventSource.onopen = (event) => {
                    connected = true;
                    clearTimeout(timeout);
                    updateStatus('sse', 'Connected', 'SSE connection established successfully');
                    log('SSE connection established', 'success');
                    
                    // Close after getting connection
                    setTimeout(() => {
                        eventSource.close();
                        const details = `Connected successfully. Messages received: ${messages.length}\n${JSON.stringify(messages, null, 2)}`;
                        updateStatus('sse', 'Success', details);
                    }, 3000);
                };
                
                eventSource.onmessage = (event) => {
                    log(`SSE message: ${event.data}`);
                    messages.push({
                        timestamp: new Date().toISOString(),
                        data: event.data
                    });
                };
                
                eventSource.onerror = (error) => {
                    clearTimeout(timeout);
                    eventSource.close();
                    const details = `SSE Error: ${error.message || 'Connection failed'}\nReadyState: ${eventSource.readyState}`;
                    updateStatus('sse', 'Error', details);
                    log(`SSE error: ${error.message || 'Connection failed'}`, 'error');
                };
                
            } catch (error) {
                updateStatus('sse', 'Failed', `SSE test failed: ${error.message}`);
                log(`SSE test failed: ${error.message}`, 'error');
            }
        }

        async function testWebRTCSignaler() {
            log('üîó Testing WebRTC signaler connectivity...');
            updateStatus('webrtc', 'Testing...', 'Connecting to WebRTC signaler...');

            try {
                if (typeof io === 'undefined') {
                    updateStatus('webrtc', 'Failed', 'Socket.IO library not loaded');
                    log('Socket.IO library not available', 'error');
                    return;
                }
                
                const socket = io('https://share.volunteerlogin.org', {
                    transports: ['polling', 'websocket'],
                    forceNew: true,
                    timeout: 10000
                });
                
                let connected = false;
                let events = [];
                
                const timeout = setTimeout(() => {
                    if (!connected) {
                        socket.disconnect();
                        updateStatus('webrtc', 'Timeout', 'WebRTC signaler connection timed out');
                        log('WebRTC signaler connection timed out', 'error');
                    }
                }, 15000);
                
                socket.on('connect', () => {
                    connected = true;
                    clearTimeout(timeout);
                    log(`WebRTC signaler connected: ${socket.id}`, 'success');
                    events.push({ event: 'connect', socketId: socket.id, transport: socket.io.engine.transport.name });
                    
                    // Test joining a room
                    socket.emit('join-room', {
                        room: 'diagnostic-test-room',
                        userId: 'diagnostic-user',
                        authToken: 'diagnostic-test-token-1234567890'
                    });
                });
                
                socket.on('join-confirmed', (data) => {
                    log(`Join confirmed: ${JSON.stringify(data)}`, 'success');
                    events.push({ event: 'join-confirmed', data });
                });
                
                socket.on('auth-failed', (data) => {
                    log(`Auth failed: ${JSON.stringify(data)}`, 'warning');
                    events.push({ event: 'auth-failed', data });
                });
                
                socket.on('error', (error) => {
                    log(`WebRTC signaler error: ${error}`, 'error');
                    events.push({ event: 'error', error: error.toString() });
                });
                
                socket.on('disconnect', (reason) => {
                    log(`WebRTC signaler disconnected: ${reason}`, 'warning');
                    events.push({ event: 'disconnect', reason });
                    
                    const details = `Events: ${events.length}\n${JSON.stringify(events, null, 2)}`;
                    const status = connected ? 'Success' : 'Failed';
                    updateStatus('webrtc', status, details);
                });
                
                // Disconnect after 10 seconds
                setTimeout(() => {
                    if (socket.connected) {
                        socket.disconnect();
                        const details = `Connected successfully. Events: ${events.length}\n${JSON.stringify(events, null, 2)}`;
                        updateStatus('webrtc', 'Success', details);
                    }
                }, 10000);
                
            } catch (error) {
                updateStatus('webrtc', 'Failed', `WebRTC signaler test failed: ${error.message}`);
                log(`WebRTC signaler test failed: ${error.message}`, 'error');
            }
        }

        async function testWithDifferentAuth() {
            log('üîê Testing different authentication methods...');
            updateStatus('auth', 'Testing...', 'Testing various auth token sources...');

            const authTests = [
                {
                    name: 'No Auth Token',
                    token: null,
                    headers: {}
                },
                {
                    name: 'Basic Test Token',
                    token: 'test-token-1234567890',
                    headers: {
                        'Authorization': 'Bearer test-token-1234567890',
                        'X-Session-Token': 'test-token-1234567890'
                    }
                },
                {
                    name: 'Long Auth Token',
                    token: 'long-test-authentication-token-with-more-characters-1234567890',
                    headers: {
                        'Authorization': 'Bearer long-test-authentication-token-with-more-characters-1234567890',
                        'X-Session-Token': 'long-test-authentication-token-with-more-characters-1234567890'
                    }
                }
            ];

            let results = [];
            
            for (const test of authTests) {
                try {
                    log(`Testing ${test.name}...`);
                    
                    // Create a ScreenSharingControl instance
                    const control = new ScreenSharingControl({
                        volunteerID: 'diagnostic-user',
                        role: 'trainer',
                        roomName: 'diagnostic-room',
                        sessionToken: test.token
                    });
                    
                    // Test auth header building
                    const headers = control.buildAuthHeaders();
                    
                    // Test API call with different auth
                    try {
                        const response = await fetch('https://share.volunteerlogin.org/api.php/health', {
                            method: 'GET',
                            headers: headers
                        });
                        
                        const result = {
                            name: test.name,
                            token: test.token ? `${test.token.substring(0, 20)}...` : 'None',
                            headersBuilt: Object.keys(headers).length,
                            hasAuth: !!(headers['Authorization'] || headers['X-Session-Token']),
                            status: response.status,
                            statusText: response.statusText,
                            ok: response.ok
                        };
                        
                        results.push(result);
                        log(`${test.name}: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'warning');
                        
                    } catch (fetchError) {
                        const result = {
                            name: test.name,
                            token: test.token ? `${test.token.substring(0, 20)}...` : 'None',
                            error: fetchError.message
                        };
                        
                        results.push(result);
                        log(`${test.name}: ${fetchError.message}`, 'error');
                    }
                    
                } catch (error) {
                    const result = {
                        name: test.name,
                        error: error.message
                    };
                    
                    results.push(result);
                    log(`${test.name}: ${error.message}`, 'error');
                }
            }
            
            const details = JSON.stringify(results, null, 2);
            updateStatus('auth', 'Complete', details);
            log('Authentication tests completed', 'success');
        }

        async function testAllEndpoints() {
            log('üîç Running comprehensive diagnostic tests...');
            
            clearLog();
            
            const tests = [
                { name: 'API Connectivity', fn: testAPIConnectivity },
                { name: 'SSE Connectivity', fn: testSSEConnectivity },
                { name: 'WebRTC Signaler', fn: testWebRTCSignaler },
                { name: 'Authentication', fn: testWithDifferentAuth }
            ];
            
            for (const test of tests) {
                log(`\n--- Running ${test.name} ---`);
                try {
                    await test.fn();
                } catch (error) {
                    log(`${test.name} failed: ${error.message}`, 'error');
                }
                
                // Brief pause between tests
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            log('\nüèÅ All diagnostic tests completed!');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('üîç ScreenSharingControl Diagnostic Test loaded');
            log('üì° This will test connectivity to all live endpoints');
            log('‚ÑπÔ∏è Click "Test All Endpoints" to run full diagnostics');
        });
    </script>
</body>
</html>