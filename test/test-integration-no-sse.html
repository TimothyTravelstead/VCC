<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenSharingControl - No SSE Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #fafafa; }
        .session-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .session-box { border: 2px solid #007bff; border-radius: 8px; padding: 15px; background: #f8f9ff; }
        .trainer-box { border-color: #28a745; background: #f8fff8; }
        .trainee-box { border-color: #17a2b8; background: #f8ffff; }
        video { width: 100%; height: 200px; background: #000; border-radius: 4px; margin: 10px 0; }
        button { padding: 8px 16px; margin: 4px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        button:hover { opacity: 0.8; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { padding: 5px 10px; border-radius: 3px; font-size: 12px; font-weight: bold; margin: 5px 0; }
        .status-connected { background: #d4edda; color: #155724; }
        .status-disconnected { background: #f8d7da; color: #721c24; }
        .status-pending { background: #fff3cd; color: #856404; }
        .log-box { height: 300px; overflow-y: scroll; background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; font-family: monospace; font-size: 11px; white-space: pre-wrap; }
        .connection-info { font-size: 10px; color: #666; margin: 5px 0; }
        .alert-box { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 15px; border-radius: 5px; margin: 15px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß ScreenSharingControl - WebRTC-Only Test</h1>
        <p><strong>Testing without SSE dependency (direct WebRTC signaling)</strong></p>
        
        <div class="alert-box">
            <strong>üîß SSE Bypass Mode:</strong> This test bypasses the SSE requirement and focuses purely on WebRTC peer-to-peer connections. 
            Since SSE is having issues on the server, we'll test the core WebRTC functionality that your optimizations improved.
        </div>
        
        <div class="test-section">
            <h3>üéÆ WebRTC Direct Test</h3>
            <button onclick="runWebRTCTest()" class="btn-primary">Run WebRTC Test</button>
            <button onclick="initializeSessions()" class="btn-success">1. Initialize Sessions</button>
            <button onclick="startTrainerSharing()" class="btn-success">2. Start Sharing</button>
            <button onclick="forceConnectionCreation()" class="btn-warning">3. Force Peer Connection</button>
            <button onclick="cleanupSessions()" class="btn-danger">Cleanup</button>
            <button onclick="clearLog()" class="btn-primary">Clear Log</button>
        </div>

        <div class="session-container">
            <div class="session-box trainer-box">
                <h3>üë®‚Äçüè´ Trainer Session</h3>
                <div id="trainerStatus" class="status status-disconnected">Disconnected</div>
                <video id="trainerVideo" muted></video>
                <div class="connection-info">
                    <div>WebRTC: <span id="trainerWebRTC">‚ùå</span></div>
                    <div>Sharing: <span id="trainerSharing">‚ùå</span></div>
                    <div>Peers: <span id="trainerPeers">0</span></div>
                    <div>Socket ID: <span id="trainerSocketId">-</span></div>
                </div>
            </div>

            <div class="session-box trainee-box">
                <h3>üë®‚Äçüéì Trainee Session</h3>
                <div id="traineeStatus" class="status status-disconnected">Disconnected</div>
                <video id="traineeVideo" muted autoplay></video>
                <div class="connection-info">
                    <div>WebRTC: <span id="traineeWebRTC">‚ùå</span></div>
                    <div>Receiving: <span id="traineeReceiving">‚ùå</span></div>
                    <div>Peers: <span id="traineePeers">0</span></div>
                    <div>Socket ID: <span id="traineeSocketId">-</span></div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>üìù Test Log</h3>
            <div id="testLog" class="log-box"></div>
        </div>
    </div>

    <!-- Load Socket.IO for WebRTC signaling -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <!-- Load the ScreenSharingControl class -->
    <script src="trainingShare/screenSharingControl.js"></script>

    <script>
        let trainerSession = null;
        let traineeSession = null;

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('testLog');
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logDiv.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            document.getElementById('testLog').textContent = '';
        }

        function updateStatus(role, status) {
            const statusElement = document.getElementById(`${role}Status`);
            statusElement.textContent = status;
            statusElement.className = `status ${status.toLowerCase().includes('connected') || status.toLowerCase().includes('sharing') ? 'status-connected' : 
                                              status.toLowerCase().includes('error') || status.toLowerCase().includes('failed') ? 'status-disconnected' : 'status-pending'}`;
        }

        function updateConnectionIndicator(role, type, value) {
            const element = document.getElementById(`${role}${type}`);
            if (element) {
                element.textContent = typeof value === 'boolean' ? (value ? '‚úÖ' : '‚ùå') : value;
            }
        }

        // Create a WebRTC-only version that bypasses SSE
        class WebRTCOnlyScreenSharingControl extends ScreenSharingControl {
            constructor(options) {
                super(options);
                this.skipSSE = true;
            }

            async initializeAPI() {
                log(`${this.volunteerID}: Mocking API for WebRTC-only test...`);
                this.apiReady = true;
                this.roomId = `webrtc-room-${this.roomName}`;
                return Promise.resolve();
            }

            async joinRoomViaAPI() {
                log(`${this.volunteerID}: Mocking room join...`);
                return Promise.resolve();
            }

            async initializeSSE() {
                log(`${this.volunteerID}: Bypassing SSE (server issues)...`);
                this.sseReady = true;
                
                // Simulate essential SSE events without actual SSE connection
                setTimeout(() => {
                    this.handleSSEMessage({
                        type: 'room_state_ready',
                        room_id: this.roomId
                    });
                }, 500);

                setTimeout(() => {
                    this.handleSSEMessage({
                        type: 'participants_update',
                        participants: [
                            { user_id: this.volunteerID, user_name: this.volunteerID, role: this.role }
                        ]
                    });
                }, 1000);

                return Promise.resolve();
            }

            async apiCall(endpoint, method, data) {
                log(`${this.volunteerID}: Mock API: ${method} ${endpoint}`);
                if (endpoint.includes('screenshare/start')) {
                    return { success: true, sessionId: 'mock-session' };
                }
                return { success: true };
            }

            // Enhanced peer connection monitoring
            getOrCreatePeer(peerId) {
                log(`${this.volunteerID}: Creating peer connection to ${peerId}`);
                const pc = super.getOrCreatePeer(peerId);
                
                // Add enhanced monitoring
                pc.ontrack = (event) => {
                    log(`${this.volunteerID}: üé• Received remote stream from ${peerId}!`, 'success');
                    if (this.remoteVideo && event.streams && event.streams[0]) {
                        this.remoteVideo.srcObject = event.streams[0];
                        this.remoteVideo.style.display = 'block';
                        this.remoteVideo.play().catch(e => log(`Video play error: ${e.message}`, 'warning'));
                        
                        if (this.role === 'trainee') {
                            log('üéâ SUCCESS! Trainee is receiving trainer\'s screen!', 'success');
                        }
                    }
                };
                
                pc.oniceconnectionstatechange = () => {
                    log(`${this.volunteerID}: ICE state with ${peerId}: ${pc.iceConnectionState}`);
                };
                
                pc.onconnectionstatechange = () => {
                    log(`${this.volunteerID}: Connection state with ${peerId}: ${pc.connectionState}`);
                };
                
                return pc;
            }

            handleWebRTCSignal(data) {
                log(`${this.volunteerID}: üì° WebRTC signal: ${data.type} from ${data.fromUserId || data.from}`);
                return super.handleWebRTCSignal(data);
            }
        }

        function monitorSession(session, role) {
            const checkConnections = () => {
                updateConnectionIndicator(role, 'WebRTC', session.socketReady);
                updateConnectionIndicator(role, 'Sharing', session.isSharing);
                updateConnectionIndicator(role, 'Peers', session.peers.size);
                updateConnectionIndicator(role, 'SocketId', session.socket?.id || '-');
                
                if (role === 'trainee') {
                    const hasVideo = session.remoteVideo && session.remoteVideo.srcObject;
                    updateConnectionIndicator(role, 'Receiving', hasVideo);
                }
            };
            
            setInterval(checkConnections, 1000);
        }

        async function initializeSessions() {
            log('üöÄ Initializing WebRTC-only sessions...');

            try {
                // Create trainer
                trainerSession = new WebRTCOnlyScreenSharingControl({
                    volunteerID: 'webrtc-trainer',
                    role: 'trainer',
                    roomName: 'webrtc-test-room',
                    trainerID: 'webrtc-trainer',
                    sessionToken: 'webrtc-test-token-1234567890'
                });

                trainerSession.remoteVideo = document.getElementById('trainerVideo');
                monitorSession(trainerSession, 'trainer');

                await trainerSession.init();
                updateStatus('trainer', 'Initialized');
                log('‚úÖ Trainer initialized', 'success');

                // Create trainee
                traineeSession = new WebRTCOnlyScreenSharingControl({
                    volunteerID: 'webrtc-trainee',
                    role: 'trainee',
                    roomName: 'webrtc-test-room',
                    trainerID: 'webrtc-trainer',
                    sessionToken: 'webrtc-test-token-1234567890'
                });

                traineeSession.remoteVideo = document.getElementById('traineeVideo');
                monitorSession(traineeSession, 'trainee');

                await traineeSession.init();
                updateStatus('trainee', 'Initialized');
                log('‚úÖ Trainee initialized', 'success');

                log('‚úÖ Both sessions ready for WebRTC testing!', 'success');

            } catch (error) {
                log(`‚ùå Initialization failed: ${error.message}`, 'error');
            }
        }

        async function startTrainerSharing() {
            if (!trainerSession) {
                log('‚ùå Initialize sessions first', 'error');
                return;
            }

            try {
                log('üì∫ Getting screen capture...');
                updateStatus('trainer', 'Getting Screen...');

                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { width: 1920, height: 1080 },
                    audio: false
                });

                document.getElementById('trainerVideo').srcObject = stream;
                
                log('‚úÖ Screen captured, starting share...', 'success');
                updateStatus('trainer', 'Starting Share...');

                trainerSession.localStream = stream;
                await trainerSession.startScreenShare();
                
                updateStatus('trainer', 'Sharing Active');
                log('‚úÖ Trainer is now sharing screen!', 'success');

            } catch (error) {
                if (error.name === 'NotAllowedError') {
                    log('‚ùå Screen sharing permission denied', 'error');
                } else {
                    log(`‚ùå Screen sharing failed: ${error.message}`, 'error');
                }
                updateStatus('trainer', 'Share Failed');
            }
        }

        function forceConnectionCreation() {
            if (!trainerSession || !traineeSession) {
                log('‚ùå Initialize sessions first', 'error');
                return;
            }

            log('üîó Forcing peer connection creation...');

            // Force trainer to create offer to trainee
            if (trainerSession.isSharing) {
                log('Trainer creating offer to trainee...');
                trainerSession.scheduleOfferCreation('webrtc-trainee');
            } else {
                log('‚ö†Ô∏è Trainer is not sharing. Start sharing first.', 'warning');
            }

            // Check connection status after a delay
            setTimeout(() => {
                const trainerPeers = trainerSession.peers.size;
                const traineePeers = traineeSession.peers.size;
                
                if (trainerPeers > 0 || traineePeers > 0) {
                    log(`‚úÖ Peer connections created: Trainer=${trainerPeers}, Trainee=${traineePeers}`, 'success');
                } else {
                    log('‚ùå No peer connections created. Check WebRTC signaling.', 'error');
                }
            }, 3000);
        }

        async function runWebRTCTest() {
            log('üöÄ Running complete WebRTC test...');
            clearLog();

            await initializeSessions();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await startTrainerSharing();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            forceConnectionCreation();
        }

        async function cleanupSessions() {
            log('üßπ Cleaning up sessions...');

            if (trainerSession) {
                await trainerSession.destroy();
                trainerSession = null;
            }

            if (traineeSession) {
                await traineeSession.destroy();
                traineeSession = null;
            }

            updateStatus('trainer', 'Disconnected');
            updateStatus('trainee', 'Disconnected');
            
            ['trainer', 'trainee'].forEach(role => {
                ['WebRTC', 'Sharing', 'Receiving', 'Peers', 'SocketId'].forEach(type => {
                    updateConnectionIndicator(role, type, type === 'Peers' || type === 'SocketId' ? (type === 'Peers' ? '0' : '-') : false);
                });
            });

            document.getElementById('trainerVideo').srcObject = null;
            document.getElementById('traineeVideo').srcObject = null;

            log('‚úÖ Cleanup completed', 'success');
        }

        document.addEventListener('DOMContentLoaded', () => {
            log('üîß WebRTC-Only ScreenSharingControl Test loaded');
            log('üì° This bypasses SSE issues and tests pure WebRTC functionality');
            log('‚ÑπÔ∏è Click "Run WebRTC Test" to test your optimizations');
        });
    </script>
</body>
</html>